<template>
  <div>
    <h1>Right-Heavy HV Layout Algorithm</h1>
    <p class='description'>
      An algorithm for producing grid-like visualizations of binary trees.
    </p>
    <article>
      <section>
        <p>
          Most commonly, trees are visualized in a layered way. See the <a @click="$router.push('/reingold-tilford')">Reingold-Tilford Algorithm</a> for examples. However, sometimes different layout types are needed. One of those is the <b>HV-Layout</b>.
        </p>

        <div class="flex flex-col sm:flex-row flex-1 items-center">
          <div>
            <tree
              :edges="rtEdges"
              :vertices="rtVertices"
              :leftMax="-3"
            />
          </div>
          <div>
            <tree
              class="mx-auto"
              :edges="edges"
              :vertices="vertices"
              :leftMax="0"
              :width="'350'"
            />
          </div>
        </div>
        <p class="description text-center">
          Two visualizations of the same binary tree. Left is generated by the <a @click="$router.push('/reingold-tilford')">Reingold-Tilford Algorithm</a>, right by the Right-Heavy HV Layout Algorithm.
        </p>

        <p>
          The HV-Layout fulfills the following conventions:
        </p>

        <ul>
          <li>
            Nodes are points with integer coordinates.
          </li>
          <li>
            Each edge is a horizontal or vertical line. Note that this means that HV-Layouts are not strictly upward.
          </li>
          <li>
            Edges do not intersect.
          </li>
          <li>
            The bounding boxes of the two subtrees of a node do not overlap.
          </li>
        </ul>
      </section>
      <section>
        <h2>Idea</h2>

        <p>
          The idea behind the generation of HV-Layouts is <b>divide and conquer</b> (just like the <a @click="$router.push('/reingold-tilford')">Reingold-Tilford Algorithm</a>).
        </p>
        <p>
          At each step, we are combining two HV-Layouts. We have two possibilities:
        </p>
        <ul>
          <li>
            <b>Horizontal combination</b>: put the node's smaller subtree (the one with less nodes) underneath the node. The larger subtree is placed as close as possible (without intersecting the smaller subtree) at the right of the node.
          </li>
          <li>
            <b>Vertical combination</b>: Put the node's larger subtree at the right of the node. The smaller subtree is placed as close as possible (without intersecting the larger subtree) underneath the node.
          </li>
        </ul>

        <img class="block lg:w-1/2 mx-auto mt-4" :src="require('@/assets/img/combinations.jpg')" alt="Horizontal and vertical combination of subtrees.">
        <p class="description text-center">Horizontal combination (left) and vertical combination (right).</p>

        <p>
          Using the right-heavy approach, horizontal combination is going to be used at each step.
        </p>
      </section>
      <section>
        <h2>Implementation</h2>

        <p>
          The algorithm is implemented in two steps. In the first step, we are going to compute <i>relative offsets</i>, <i>node counts</i> and <i>boundaries</i> for each node in post-order fashion (see  <a @click="$router.push('/reingold-tilford')">Reingold-Tilford Algorithm</a> for an explanation of post-order). In the second step, we are going to serialize the nodes into a list and propagate the offsets to the children of each node (by adding the parent's offsets to the children's offsets).
        </p>

        <h3 class="mt-4">Post-Order Step</h3>

        <ul>
          <li>
            <b>Leaves</b>: Set the bounds to <span class="mono">[0, 0]</span> and the node count to <span class="mono">1</span>.
          </li>
          <li>
            <b>Non-leaf subtree offsets</b>: For non-leaves, determine the subtree with less nodes. This subtree is placed directly underneath the subtree's root, therefore its offset is <span class="mono">[0, 1]</span>. The larger subtree's offset in y-direction is <span class="mono">0</span>, as it is positioned at the same height as the non-leaf. The subtree's offset in x-direction is determined by adding <span class="mono">1</span> to the x-boundary of the smaller subtree.
          </li>
          <li>
            <b>Non-leaf node counts</b>: For non-leaves, sum up the node counts of its subtrees and add <span class="mono">1</span>.
          </li>
          <li>
            <b>Non-leaf boundaries</b>: The boundaries of a tree can be computed as follows: The x-boundary is the sum of the x-boundaries of its subtrees plus <span class="mono">1</span>, the y-boundary either the y-boundary of the larger subtree or the y-boundary of the smaller subtree plus <span class="mono">1</span> &mdash; whichever is bigger.
          </li>
          <li>Repeat until the root is reached.</li>
        </ul>

        <h3 class="mt-4">Pre-Order Serialization</h3>

        <p>
          To serialize the tree, add the root to an empty node list. If the root has subtrees, add the root's offset to the offsets of each subtree, add the edge between the root and the subtree and repeat the serialization on it.
        </p>

        <p>
          See <a href="https://github.com/jens-ox/agv/blob/master/src/views/HVLayout.vue">the code on GitHub</a> for the concrete implementation.
        </p>
      </section>
      <section>
        <h2>Complexity</h2>

        <p>
          For each step of the algorithm, only a fixed number of operations needs to be done for each node. Therefore, the <b>time complexity</b> is
        </p>
        <p class="formula">O(n).</p>

        <p>
          The width of the generated visualization is at most <span class="serif">n</span> (e.g. a binary tree where each node but the last has exactly one child).
        </p>
        <p>
          The height is at most <span class="serif">log(n)</span>. The reason for that is, that in the worst case, each subtree has the same amount of nodes in each step. Therefore, the number of nodes is at least halved in each step, leading to a logarithmic depth.
        </p>
        <p>
          This leads us to a <b>area complexity</b> of
        </p>
        <p class="formula">O(nlog(n)).</p>
      </section>
      <section>
        <h2>Improvements</h2>

        <p>
          As you can see in the example above, the space needed by the Right-Heavy approach is far from optimal. Optimal space can be achieved through dynamic programming, but not in an easy way. See the <a href="https://link.springer.com/chapter/10.1007/3-540-63938-1_82">Paper by Crescenzi and Penna</a> for further information
        </p>
      </section>
    </article>
  </div>
</template>

<script>
import Tree from '@/components/Tree.vue'

export default {
  components: { Tree },
  methods: {
    computeOffsets (tree) {
      tree.nodeCount = 1
      if (!tree.right && !tree.left) {
        tree.bounds = [0, 0]
      }
      if (tree.right) {
        this.computeOffsets(tree.right)
        tree.nodeCount += tree.right.nodeCount
      }
      if (tree.left) {
        this.computeOffsets(tree.left)
        tree.nodeCount += tree.left.nodeCount
      }

      // compute bounds and offsets
      if (tree.right && !tree.left) {
        // only one subtree exists --> is automatically the larger one --> place it to the right
        tree.right.offset = [1, 0]
        tree.bounds = [tree.right.bounds[0] + 1, tree.right.bounds[1]]
      }
      if (tree.left && !tree.right) {
        tree.left.offset = [1, 0]
        tree.bounds = [tree.left.bounds[0] + 1, tree.left.bounds[1]]
      }
      if (tree.left && tree.right) {
        if (tree.left.nodeCount > tree.right.nodeCount) {
          // left tree to the right
          tree.left.offset = [tree.right.bounds[0] + 1, 0]

          // right tree to the bottom
          tree.right.offset = [0, 1]

          tree.bounds = [tree.right.bounds[0] + 1 + tree.left.bounds[0], Math.max(tree.left.bounds[1], tree.right.bounds[1] + 1)]
        } else {
          // right tree to the right
          tree.right.offset = [tree.left.bounds[0] + 1, 0]

          // left tree to the bottom
          tree.left.offset = [0, 1]

          tree.bounds = [tree.left.bounds[0] + 1 + tree.right.bounds[0], Math.max(tree.right.bounds[1], tree.left.bounds[1] + 1)]
        }
      }
    },

    serializeTree (tree) {
      // root: set offsets to [0, 0]
      tree.offset = tree.offset || [0, 0]

      // add vertex to list
      const vertex = {
        name: tree.name,
        x: tree.offset[0],
        y: tree.offset[1]
      }
      this.vertices.push(vertex)

      // propagate offsets
      if (tree.left) {
        tree.left.offset = [tree.left.offset[0] + tree.offset[0], tree.left.offset[1] + tree.offset[1]]
        this.edges.push({
          from: vertex,
          to: {
            name: tree.left.name,
            x: tree.left.offset[0],
            y: tree.left.offset[1]
          }
        })
        this.serializeTree(tree.left)
      }
      if (tree.right) {
        tree.right.offset = [tree.right.offset[0] + tree.offset[0], tree.right.offset[1] + tree.offset[1]]
        this.edges.push({
          from: vertex,
          to: {
            name: tree.right.name,
            x: tree.right.offset[0],
            y: tree.right.offset[1]
          }
        })
        this.serializeTree(tree.right)
      }
    }
  },
  beforeMount () {
    this.computeOffsets(this.binaryTree)
    this.serializeTree(this.binaryTree)
  },
  data () {
    return {
      vertices: [],
      edges: [],
      binaryTree: {
        name: 'r',
        left: {
          name: 'a',
          left: {
            name: 'b',
            right: {
              name: 'c',
              left: {
                name: 'd'
              },
              right: {
                name: 'e',
                right: {
                  name: 'f'
                }
              }
            }
          }
        },
        right: {
          name: 'g',
          left: {
            name: 'h',
            left: {
              name: 'i'
            },
            right: {
              name: 'j'
            }
          },
          right: {
            name: 'k'
          }
        }
      },
      rtVertices: [
        { name: 'r', x: 0, y: 0 },
        { name: 'a', x: -2, y: 1 },
        { name: 'b', x: -3, y: 2 },
        { name: 'c', x: -2, y: 3 },
        { name: 'd', x: -3, y: 4 },
        { name: 'e', x: -1, y: 4 },
        { name: 'f', x: 0, y: 5 },
        { name: 'g', x: 2, y: 1 },
        { name: 'h', x: 1, y: 2 },
        { name: 'i', x: 0, y: 3 },
        { name: 'j', x: 2, y: 3 },
        { name: 'k', x: 3, y: 2 }
      ],
      rtEdges: [
        { from: { x: 0, y: 0 }, to: { x: -2, y: 1 } },
        { from: { x: -2, y: 1 }, to: { x: -3, y: 2 } },
        { from: { x: -3, y: 2 }, to: { x: -2, y: 3 } },
        { from: { x: -2, y: 3 }, to: { x: -3, y: 4 } },
        { from: { x: -2, y: 3 }, to: { x: -1, y: 4 } },
        { from: { x: -1, y: 4 }, to: { x: 0, y: 5 } },
        { from: { x: 0, y: 0 }, to: { x: 2, y: 1 } },
        { from: { x: 2, y: 1 }, to: { x: 1, y: 2 } },
        { from: { x: 1, y: 2 }, to: { x: 0, y: 3 } },
        { from: { x: 1, y: 2 }, to: { x: 2, y: 3 } },
        { from: { x: 2, y: 1 }, to: { x: 3, y: 2 } }
      ]
    }
  }
}
</script>
